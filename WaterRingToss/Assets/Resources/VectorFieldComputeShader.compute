#pragma kernel CSMain

RWStructuredBuffer<float3> vectorField;
RWStructuredBuffer<float3> newVectorField;

int3 fieldDimensions;
float3 positionStep;

bool isJetActive;
float3 jetLocalPosition;
float jetRadius;
float3 jetForce;

static float waveTransferRate = 0.51f;
static float waveRelaxRate = 0.99f;


float3 FlipEdge(uint3 id, float3 self);


[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // get current v index
    int selfIndex = id.x * (fieldDimensions.y * fieldDimensions.z) + id.y * fieldDimensions.z + id.z;
    // local vector pos
    float3 selfPos = float3(    positionStep.x * 0.5f + id.x * positionStep.x,
                                positionStep.y * 0.5f + id.y * positionStep.y,
                                positionStep.z * 0.5f + id.z * positionStep.z );


    // position local to jet
    float3 localToJet = jetLocalPosition - selfPos;
    // distance to jet
    float distanceToJet = length(localToJet);
    

    // Vector affected by jet
    if ( (distanceToJet < jetRadius)  && isJetActive ) 
    {
        float multiplier = distanceToJet / jetRadius;
        
        float3 summVector = jetForce * multiplier;//(normalize(localToJet * -1) * length(jetForce)) * 0.5f * multiplier;

        newVectorField[selfIndex] = summVector;
        
        return;
    } 
    


    // Vector not affected by jet
    {
        // flip vector, if at edge
        // x
        float3 self = vectorField[selfIndex];

        float3 summAddProjectedNeigh = float3(0,0,0);
        float neighAddCounter = 0;

        float3 summSubProjectedNeigh = float3(0,0,0);
        float neighSubCounter = 0;

        for (int i=0; i<27; i++)
        {
            if (i==13)
                i++;
            
            // neighbor delta indices
            int x = i / 9;
            int y = (i - (x * 9)) / 3;
            int z = i % 3;
            int3 neighborFieldPos = int3(id.x + (x-1), id.y + (y-1), id.z + (z-1));

            if ( (neighborFieldPos.x<0) || (neighborFieldPos.x>=fieldDimensions.x) ||
                 (neighborFieldPos.y<0) || (neighborFieldPos.y>=fieldDimensions.y) ||
                 (neighborFieldPos.z<0) || (neighborFieldPos.z>=fieldDimensions.z) )
                continue;

            int neighborIndex = (neighborFieldPos.x * (fieldDimensions.y * fieldDimensions.z)) + (neighborFieldPos.y * fieldDimensions.z) + neighborFieldPos.z;
            float3 neighSelf = vectorField[neighborIndex];

            float3 neighborPos = float3(    positionStep.x * 0.5f + neighborFieldPos.x * positionStep.x,
                                            positionStep.x * 0.5f + neighborFieldPos.y * positionStep.y,
                                            positionStep.x * 0.5f + neighborFieldPos.z * positionStep.z );
            
            // if neighbor is aimed at self
            float3 posNeighToSelfNorm = normalize(selfPos - neighborPos);
            float dotProductN = dot(neighSelf, posNeighToSelfNorm);
            if ( (dotProductN > 0) )
            {
                float3 projectedNeigh = dotProductN * posNeighToSelfNorm;
                summAddProjectedNeigh += projectedNeigh;
                neighAddCounter += 1;
            }

            // if self is aimed at neighbor
            float3 posSelfToNeighfNorm = normalize(neighborPos - selfPos);
            float dotProductS = dot(self, posSelfToNeighfNorm);
            if ( (dotProductS > 0) )
            {
                float3 projectedSelf = dotProductS * posSelfToNeighfNorm;
                summSubProjectedNeigh += projectedSelf;
                neighSubCounter += 1;
            }
        }

        float3 averageAdd = float3(0,0,0);
        if (neighAddCounter > 0)
        {
            averageAdd = summAddProjectedNeigh / neighAddCounter;
        }

        float3 averageSub = float3(0,0,0);
        if (neighSubCounter > 0)
        {
            averageSub = summSubProjectedNeigh / neighSubCounter;
        }

        float3 diff = (averageAdd - averageSub) * waveTransferRate;
            
        float3 result = self + diff;

        result = FlipEdge(id, result);
                
        newVectorField[selfIndex] = result * waveRelaxRate;
    }
}

float3 FlipEdge(uint3 id, float3 self)
{
    float revMult = -0.9f;

    //x
    if (((id.x == 0) && (self.x < 0)) ||
        ((id.x >= (fieldDimensions.x-1)) && (self.x > 0)) )
        self.x *= revMult;

    // y
    if (((id.y == 0) && (self.y < 0)) ||
        ((id.y >= (fieldDimensions.y-1)) && (self.y > 0)) )
        self.y *= revMult;

    // z
    if (((id.z == 0) && (self.z < 0)) ||
        ((id.z >= (fieldDimensions.z-1)) && (self.z > 0)) )
        self.z *= revMult;


    return self;
}