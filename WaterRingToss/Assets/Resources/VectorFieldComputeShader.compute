#pragma kernel CSMain

RWStructuredBuffer<float> pressureField;
RWStructuredBuffer<float> newPressureField;

int3 fieldDimensions;
float3 positionStep;

bool isJetActive;
float3 jetLocalPosition;
float jetRadius;
float3 jetForce;

static float pressureTransferRate = 0.999f;
static float pressureRelaxRate = 0.99f;

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // get current v index
    int selfIndex = id.x * (fieldDimensions.y * fieldDimensions.z) + id.y * fieldDimensions.z + id.z;
    // local vector pos
    float3 selfPos = float3(positionStep.x * 0.5f + id.x * positionStep.x,
                            positionStep.y * 0.5f + id.y * positionStep.y,
                            positionStep.z * 0.5f + id.z * positionStep.z );


    // position local to jet
    float3 localToJet = jetLocalPosition - selfPos;
    // distance to jet
    float distanceToJet = length(localToJet);
    

    // Vector affected by jet
    if ( (distanceToJet < jetRadius)  && isJetActive ) 
    {
        float multiplier = distanceToJet / jetRadius;

        newPressureField[selfIndex] = 1 * multiplier;

        return;
    } 
    


    // Vector not affected by jet
    {
        float self = pressureField[selfIndex];

        int neighbors[9];
        float summNeighbors = 0;
        float neighborCount = 0;

        for (int i=0; i<27; i++)
        {
            if (i==13)
                i++;
            
            // neighbor delta indices
            int x = i / 9;
            int y = (i - (x * 9)) / 3;
            int z = i % 3;
            int3 neighborFieldPos = int3(id.x + (x-1), id.y + (y-1), id.z + (z-1));

            if ( (neighborFieldPos.x<0) || (neighborFieldPos.x>=fieldDimensions.x) ||
                 (neighborFieldPos.y<0) || (neighborFieldPos.y>=fieldDimensions.y) ||
                 (neighborFieldPos.z<0) || (neighborFieldPos.z>=fieldDimensions.z) )
                continue;

            int neighborIndex = (neighborFieldPos.x * (fieldDimensions.y * fieldDimensions.z)) + (neighborFieldPos.y * fieldDimensions.z) + neighborFieldPos.z;
            float neighborSelf = pressureField[neighborIndex];

            summNeighbors += neighborSelf;
            neighborCount += 1.0f;
        }

        float average = (summNeighbors + self) / (1 + neighborCount);
        float diff = average - self;

        float result = self + diff * pressureTransferRate;

        newPressureField[selfIndex] = result * pressureRelaxRate;
    }
}